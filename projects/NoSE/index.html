<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>NoSE: NoSQL Schema Evaluator - Michael Mior</title>
    <link href='/styles.css' rel='stylesheet'>
    <link href='/img/favicon.ico' rel='icon'>
    <meta content='nanoc 3.6.8' name='generator'>
    <link href='/atom.xml' rel='alternate' title='Michael Mior' type='application/atom+xml'>
  </head>
  <body class='home page'>
    <div class='hfeed' id='wrapper'>
      <div id='header'>
        <div id='blog-title'>
          <h1>
            <a href='/' rel='home' title='Michael Mior'>
              <span class='word-1'>Michael</span>
              <span class='word-2'>Mior</span>
            </a>
          </h1>
        </div>
        <div id='access'>
          <div class='skip-link'>
            <a href='#content' title='Skip navigation to the content'></a>
          </div>
          <div class='menu'>
            <ul class='sf-menu'>
              <li>
                <a href="/">Home</a>
              </li>
              <li>
                <a href="/about/">About</a>
              </li>
              <li>
                <a href="/contact/">Contact</a>
              </li>
              <li>
                <a href="/blog/archive/2014.html">Blog</a>
              </li>
              <li>
                <a href="/projects/">Projects</a>
              </li>
              <li>
                <a href="/publications/">Publications</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div id='main'>
      <div id='container'>
        <div id='content'>
          <div class='page hentry'>
  <h1 class='entry-title'>NoSE: NoSQL Schema Evaluator</h1>
  <div class='entry-content'>&#x000A;            <h1 id="abstract">Abstract</h1>&#x000A;            &#x000A;            <p>Database design is critical for high performance in relational databases and many tools exist to aid application designers in selecting an appropriate schema. While the problem of schema optimization is also highly relevant for Cassandra, existing tools for relational databases are inadequate for this setting. Application designers wishing to use Cassandra instead rely on rules of thumb to select an appropriate schema. These rules can be challenging to apply without experience because they are often vague or contradictory. No<span class="caps">SE</span>, an automated solution to Cassandra schema design, attempts to avoid these&nbsp;pitfalls.</p>&#x000A;            &#x000A;            <h1 id="introduction">Introduction</h1>&#x000A;            &#x000A;            <p>No<span class="caps">SE</span> is a system for recommending database schemas for Cassandra applications. Our cost-based approach uses a novel integer linear programming formulation to guide the mapping from a simple model of the application workload to a database&nbsp;schema. </p>&#x000A;            &#x000A;            <p>Our prototype is able to implicitly capture rules of thumb used by expert designers without explicitly encoding the rules. Automating the design process allows No<span class="caps">SE</span> to produce efficient schemas and to examine more alternatives than would be possible with a manual rule-based&nbsp;approach.</p>&#x000A;            &#x000A;            <h1 id="rule-based-schema-design">Rule-based Schema&nbsp;Design</h1>&#x000A;            &#x000A;            <p>Many experts in Cassandra data modeling have released <a href="http://www.datastax.com/dev/blog/basic-rules-of-cassandra-data-modeling">guidelines</a> on how to best design schemas. These guidelines suggest that schemas should be modeled very differently from a relational database and emphasize the importance of relying on knowledge of queries which will be issued by the&nbsp;application.</p>&#x000A;            &#x000A;            <p>This results in denormalization and data duplication in order to improve the performance of reads. In common deployment scenarios, writes are inexpensive in Cassandra and this denormalization results in improved performance across the entire application workload. However, when the workload becomes  complex, using a <span class="caps">CQL</span> table for each query can result in expensive updates and heavy storage&nbsp;utilization. </p>&#x000A;            &#x000A;            <h1 id="automating-schema-design">Automating Schema&nbsp;Design</h1>&#x000A;            &#x000A;            <p>To avoid the complexity of manually attempting to satisfy the conflicting requirements inherent in rule-based schema design, No<span class="caps">SE</span> attempts to automate this process. This automation consists of three&nbsp;steps:</p>&#x000A;            &#x000A;            <ol>&#x000A;              <li>&#x000A;                <p><strong><span class="caps">CQL</span> Table&nbsp;Enumeration</strong></p>&#x000A;            &#x000A;                <p>The schema design process starts by constructing a set of column families which are useful to answer application queries. These column families are chosen according to a simple model of query execution which uses one or more <span class="caps">CQL</span> tables to answer queries in the&nbsp;application.</p>&#x000A;              </li>&#x000A;              <li>&#x000A;                <p><strong>Query Plan&nbsp;Generation</strong></p>&#x000A;            &#x000A;                <p>In addition to these column families enumerated in step one, No<span class="caps">SE</span> assumes that some application-side logic may be necessary to answer queries. For example, if a particular <span class="caps">CQL</span> table returns data which is sorted incorrectly, the application may need to sort the data after it has been&nbsp;retrieved.</p>&#x000A;              </li>&#x000A;              <li>&#x000A;                <p><strong>Schema&nbsp;Selection</strong></p>&#x000A;            &#x000A;                <p>Each of the query plans in step two has an associated cost. We use these costs to construct an integer linear program (<span class="caps">ILP</span>) which selects a set of <span class="caps">CQL</span> tables to use for the final schema. The <span class="caps">ILP</span> implicitly explores all possible combinations of the <span class="caps">CQL</span> tables to find the combination which has the lowest&nbsp;cost.</p>&#x000A;              </li>&#x000A;            </ol>&#x000A;            &#x000A;            <p>By automating this process, No<span class="caps">SE</span> is able to explore a much larger set of possible designs than a human designer. This allows the generated schema to combine results from multiple tables to answer queries. Moreover, No<span class="caps">SE</span> does also not require the user to have expert knowledge of Cassandra in order to produce a good design. Armed only with a solid knowledge of the application being designed, any user should be able to produce an affective&nbsp;schema.</p>&#x000A;            &#x000A;            <h1 id="example-use-case">Example Use&nbsp;Case</h1>&#x000A;            &#x000A;            <p>We consider <a href="http://rubis.ow2.org/">RUBiS</a>, a simple version of an online auction website. If we attempt to recreate RUBiS as a Cassandra application, there are several entities and relationships which we must&nbsp;model.</p>&#x000A;            &#x000A;            <p><img src="../../img/projects/NoSE/rubis.png" alt="RUBiS entities" /></p>&#x000A;            &#x000A;            <p>There are several queries which the application must answer such&nbsp;as:</p>&#x000A;            &#x000A;            <ul>&#x000A;              <li>Produce the history of bids for a given&nbsp;item</li>&#x000A;              <li>Show all comments for a given&nbsp;item</li>&#x000A;              <li>Browse items within a given&nbsp;category</li>&#x000A;            </ul>&#x000A;            &#x000A;            <p>In addition, the application must support updates&nbsp;including:</p>&#x000A;            &#x000A;            <ul>&#x000A;              <li>Register a new&nbsp;user</li>&#x000A;              <li>Place a bid on an&nbsp;item</li>&#x000A;              <li>Comment on an&nbsp;item</li>&#x000A;            </ul>&#x000A;            &#x000A;            <p>Suppose one application query is to retrieve items in particular category where the end date of the auction has not passed. If items are not heavily modified, No<span class="caps">SE</span> would recommend a <span class="caps">CQL</span> table as&nbsp;follows:</p>&#x000A;            &#x000A;            <pre><code>CREATE TABLE items_by_category (&#x000A;                category_id uuid,&#x000A;                item_end_date timestamp,&#x000A;                item_name text,&#x000A;                item_description text&#x000A;                PRIMARY KEY((category_id), item_end_date, item_id)&#x000A;            )&#x000A;            </code></pre>&#x000A;            &#x000A;            <p>This allows all the items for a given category to be read by a single Cassandra query. No<span class="caps">SE</span> also provides the query to the application&nbsp;developer:</p>&#x000A;            &#x000A;            <pre><code>SELECT item_name, item_description FROM &#x000A;            items_by_category WHERE&#x000A;            category_id = ? AND item_end_date &gt; ?;&#x000A;            </code></pre>&#x000A;            &#x000A;            <p>The set of <span class="caps">CQL</span> tables and queries is provided for each application query provided by the application developer. This makes implementing the application using a Cassandra backend a very straightforward&nbsp;process.&#x000A;            Suppose items are heavily modified or new items are frequently added. In this case, we may want to reduce denormalization of item data. We may already have a <span class="caps">CQL</span> table which is used to display item detail&nbsp;pages:</p>&#x000A;            &#x000A;            <pre><code>CREATE TABLE items (&#x000A;                item_id uuid PRIMARY KEY,&#x000A;                item_name text,&#x000A;                item_description text&#x000A;            )&#x000A;            </code></pre>&#x000A;            &#x000A;            <p>In this case, we may want to reduce the item data which is stored in the items_by_category&nbsp;table</p>&#x000A;            &#x000A;            <pre><code>CREATE TABLE items_by_category (&#x000A;                category_id uuid,&#x000A;                item_end_date timestamp,&#x000A;                PRIMARY KEY((category_id), item_end_date, item_id)&#x000A;            )&#x000A;            </code></pre>&#x000A;            &#x000A;            <p>This table now provides the <span class="caps">ID</span> of an item and requires the item data to be fetched from a separate items table. This makes retrieving items by category more expensive, but will make updates to items more&nbsp;efficient.</p>&#x000A;            &#x000A;            <p>This example is simple, but demonstrates a tradeoff No<span class="caps">SE</span> is able to make. Across entire workloads, these tradeoffs consider interaction between many different queries. Because the recommendation process completes in seconds, it is also possible for the application designer to explore many different workload parameters. For example, it is easy to adjust the ratio of writes to reads and see how this affects the recommended schema and the performance of each application&nbsp;query.</p>&#x000A;            &#x000A;            <h1 id="conclusion">Conclusion</h1>&#x000A;            &#x000A;            <p>Schema design for Cassandra databases is a complex problem with many additional challenges as compared to relational schema design. We have developed a workload-driven approach for schema design which is able to effectively explore various tradeoffs in the design space. For example, No<span class="caps">SE</span> allows applications to explicitly control the tradeoff between normalization and query performance by varying a space constraint. Our approach implicitly captures best practices in Cassandra schema design with relying on general design rules-of-thumb, and is thereby able to generate effective Cassandra schema&nbsp;designs.</p>&#x000A;</div>
</div>

        </div>
      </div>
    </div>
    <div id='footer'>
      <div id='siteinfo'>
        &copy; 2013 Michael Mior
      </div>
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-45085128-1', 'mior.ca');
      ga('require', 'linkid', 'linkid.js');
      ga('send', 'pageview');
      
      window.heap=window.heap||[],heap.load=function(t,e){window.heap.appid=t,window.heap.config=e;var a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=("https:"===document.location.protocol?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+t+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(t){return function(){heap.push([t].concat(Array.prototype.slice.call(arguments,0)))}},p=["clearEventProperties","identify","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
      heap.load('1282501007');
    </script>
  </body>
</html>
